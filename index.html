<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cuphead Boss Battle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            overflow: hidden;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #mainContainer {
            display: flex;
            width: 95vw;
            max-width: 1600px;
            height: 90vh;
            max-height: 900px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }

        #leftPanel {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #0f3460 0%, #16213e 100%);
            position: relative;
            padding: 20px;
        }

        #loginModal {
            background: rgba(255, 255, 255, 0.95);
            border: 8px solid #2c1810;
            box-shadow: 0 0 0 4px #fff, 0 0 40px rgba(0,0,0,0.5);
            padding: 40px;
            border-radius: 20px;
            max-width: 450px;
            width: 100%;
            text-align: center;
        }

        #loginModal h1 {
            color: #2c1810;
            font-size: 42px;
            margin-bottom: 10px;
            text-shadow: 3px 3px 0 #ffaa00;
        }

        #loginModal p {
            color: #666;
            font-size: 16px;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .challenge-text {
            background: linear-gradient(135deg, #ff6b00 0%, #ff0000 100%);
            color: #fff;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            font-weight: bold;
            font-size: 18px;
            text-shadow: 2px 2px 0 #000;
            border: 3px solid #2c1810;
        }

        .inputGroup {
            margin-bottom: 15px;
            text-align: left;
        }

        .inputGroup label {
            display: block;
            color: #2c1810;
            font-weight: bold;
            margin-bottom: 6px;
            font-size: 14px;
        }

        .inputGroup input {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            border: 4px solid #2c1810;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            box-sizing: border-box;
        }

        .inputGroup input:focus {
            outline: none;
            border-color: #ff0000;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.3);
        }

        .loginButton {
            width: 100%;
            padding: 15px;
            font-size: 22px;
            background: #ff0000;
            color: #fff;
            border: 4px solid #2c1810;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            box-shadow: 4px 4px 0 #2c1810;
            transition: all 0.1s;
            margin-top: 10px;
        }

        .loginButton:hover {
            transform: translateY(-2px);
            box-shadow: 6px 6px 0 #2c1810;
        }

        .loginButton:active {
            transform: translateY(0);
            box-shadow: 2px 2px 0 #2c1810;
        }

        #rightPanel {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #f4e4c1 0%, #e8d4a8 100%);
            position: relative;
            padding: 20px;
        }

        canvas {
            display: block;
            background: linear-gradient(180deg, #87ceeb 0%, #f4e4c1 100%);
            border: 8px solid #2c1810;
            box-shadow: 0 0 0 4px #fff, 0 0 0 8px #2c1810;
            image-rendering: crisp-edges;
            image-rendering: pixelated;
            cursor: crosshair;
            max-width: 100%;
            max-height: 100%;
        }

        #gameContainer {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            text-shadow: 3px 3px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000;
            font-size: 20px;
            font-weight: bold;
            z-index: 10;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #fff;
            text-shadow: 3px 3px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000;
            font-size: 16px;
            font-weight: bold;
            z-index: 10;
        }

        #levelIndicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            text-shadow: 3px 3px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000;
            font-size: 24px;
            font-weight: bold;
            z-index: 10;
        }

        #bossHealth {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 250px;
        }

        .healthBar {
            background: #2c1810;
            border: 4px solid #fff;
            box-shadow: 3px 3px 0 #000;
            height: 25px;
            position: relative;
            overflow: hidden;
        }

        .healthFill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000 0%, #ff6b00 50%, #ffaa00 100%);
            transition: width 0.3s ease;
            box-shadow: inset 0 0 10px rgba(255,255,255,0.5);
        }

        .bossName {
            color: #fff;
            text-shadow: 3px 3px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: #fff;
            padding: 40px;
            border: 8px solid #fff;
            box-shadow: 0 0 0 4px #ff0000;
            text-align: center;
            display: none;
            z-index: 100;
            max-width: 80%;
        }

        #gameOver h1 {
            font-size: 42px;
            margin-bottom: 20px;
            text-shadow: 4px 4px 0 #ff0000;
        }

        #gameOver p {
            font-size: 18px;
            line-height: 1.6;
            margin-bottom: 20px;
            white-space: pre-line;
        }

        #gameOver button {
            font-size: 24px;
            padding: 15px 30px;
            margin: 10px;
            background: #ff0000;
            color: #fff;
            border: 4px solid #fff;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            box-shadow: 4px 4px 0 #000;
            transition: all 0.1s;
        }

        #gameOver button:hover {
            transform: scale(1.05);
            box-shadow: 6px 6px 0 #000;
        }

        #crosshair {
            position: absolute;
            width: 30px;
            height: 30px;
            pointer-events: none;
            z-index: 50;
            display: none;
        }

        .crosshairLine {
            position: absolute;
            background: rgba(255,255,255,0.8);
            box-shadow: 0 0 4px #000;
        }

        .crosshairH {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        .crosshairV {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        /* Logged In App Styles */
        #loggedInApp {
            display: none;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1000;
            overflow-y: auto;
        }

        .app-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .app-header {
            background: rgba(255,255,255,0.95);
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 30px;
            text-align: center;
            border: 4px solid #2c1810;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .app-header h1 {
            font-size: 48px;
            color: #2c1810;
            margin-bottom: 10px;
            text-shadow: 3px 3px 0 #ffaa00;
        }

        .app-header p {
            font-size: 20px;
            color: #666;
        }

        .user-info {
            background: rgba(255,255,255,0.95);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            border: 4px solid #2c1810;
        }

        .user-info h2 {
            color: #2c1810;
            margin-bottom: 10px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: rgba(255,255,255,0.95);
            padding: 25px;
            border-radius: 15px;
            border: 4px solid #2c1810;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .stat-card h3 {
            color: #666;
            font-size: 14px;
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        .stat-card .stat-value {
            font-size: 36px;
            color: #2c1810;
            font-weight: bold;
        }

        .logout-btn {
            background: #ff0000;
            color: #fff;
            border: 4px solid #2c1810;
            padding: 15px 40px;
            font-size: 20px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 4px 4px 0 #2c1810;
            transition: all 0.1s;
        }

        .logout-btn:hover {
            transform: translateY(-2px);
            box-shadow: 6px 6px 0 #2c1810;
        }
    </style>
</head>
<body>
    <!-- Main Container -->
    <div id="mainContainer">
        <!-- Left Panel: Login Modal -->
        <div id="leftPanel">
            <div id="loginModal">
                <h1>WELCOME!</h1>
                <p>Ready to prove your skills?</p>
                
                <div class="challenge-text">
                    ‚öîÔ∏è DEFEAT ALL 3 BOSSES TO ACCESS THE APP ‚öîÔ∏è
                </div>
                
                <p style="font-size: 14px; color: #999;">Fill in your details to begin the challenge</p>
                
                <div class="inputGroup">
                    <label for="username">Username</label>
                    <input type="text" id="username" placeholder="Enter your name" />
                </div>
                <div class="inputGroup">
                    <label for="email">Email</label>
                    <input type="email" id="email" placeholder="Enter your email" />
                </div>
                <button class="loginButton" onclick="login()">START CHALLENGE</button>
            </div>
        </div>

        <!-- Right Panel: Game -->
        <div id="rightPanel">
            <div id="gameContainer">
                <canvas id="gameCanvas"></canvas>
                
                <div id="ui">
                    <div>HP: <span id="playerHealth">100</span></div>
                    <div>SCORE: <span id="score">0</span></div>
                </div>

                <div id="levelIndicator">LEVEL <span id="currentLevel">1</span></div>

                <div id="controls">
                    <div>‚¨ÜÔ∏è W - Jump</div>
                    <div>‚¨áÔ∏è S - Duck</div>
                    <div>‚¨ÖÔ∏è A - Move Left</div>
                    <div>‚û°Ô∏è D - Move Right</div>
                    <div>üñ±Ô∏è CLICK - Shoot</div>
                </div>

                <div id="bossHealth">
                    <div class="bossName" id="bossName">KING CUDDLES</div>
                    <div class="healthBar">
                        <div class="healthFill" id="bossHealthFill" style="width: 100%"></div>
                    </div>
                </div>

                <div id="crosshair">
                    <div class="crosshairLine crosshairH"></div>
                    <div class="crosshairLine crosshairV"></div>
                </div>

                <div id="gameOver">
                    <h1 id="gameOverText">KNOCKOUT!</h1>
                    <p id="gameOverSubtext">You defeated the boss!</p>
                    <button id="retryButton" onclick="restartGame()">RETRY</button>
                    <button id="nextLevelButton" onclick="continueToNextLevel()" style="display: none;">NEXT LEVEL</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Logged In App -->
    <div id="loggedInApp">
        <div class="app-container">
            <div class="app-header">
                <h1>üéÆ WELCOME CHAMPION! üéÆ</h1>
                <p>You've proven your skills and gained access to the app!</p>
            </div>

            <div class="user-info">
                <h2>User Profile</h2>
                <p><strong>Username:</strong> <span id="appUsername">Player</span></p>
                <p><strong>Email:</strong> <span id="appEmail"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7b0b171a021e093b1c1a161e55181416">[email&#160;protected]</a></span></p>
                <p><strong>Status:</strong> ‚úÖ Verified Boss Slayer</p>
            </div>

            <div class="stats-grid">
                <div class="stat-card">
                    <h3>Final Score</h3>
                    <div class="stat-value" id="appScore">0</div>
                </div>
                <div class="stat-card">
                    <h3>Bosses Defeated</h3>
                    <div class="stat-value">3 / 3</div>
                </div>
                <div class="stat-card">
                    <h3>Difficulty</h3>
                    <div class="stat-value">EXPERT</div>
                </div>
            </div>

            <div style="text-align: center;">
                <button class="logout-btn" onclick="logout()">LOGOUT</button>
            </div>
        </div>
    </div>

    <script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const crosshair = document.getElementById('crosshair');

        canvas.width = 800;
        canvas.height = 600;

        // Boss configurations
        const bossConfigs = [
            { name: "KING CUDDLES", health: 500, attackCooldown: 120, color: '#CD853F', projectileSpeed: 4, eyeColor: '#000', accessories: 'crown', damage: 5 },
            { name: "QUEEN CHAOS", health: 750, attackCooldown: 90, color: '#9370DB', projectileSpeed: 5.5, eyeColor: '#ff00ff', accessories: 'crown_gems', damage: 10 },
            { name: "LORD MAYHEM", health: 1000, attackCooldown: 60, color: '#DC143C', projectileSpeed: 7, eyeColor: '#ff0000', accessories: 'crown_spikes', damage: 15 }
        ];

        // Powerup types
        const powerupTypes = [
            { type: 'rapidfire', color: '#00ffff', name: 'RAPID FIRE', duration: 50 },
            { type: 'health', color: '#00ff00', name: '+25 HP', duration: 0 },
            { type: 'freeze', color: '#4169e1', name: 'FREEZE', duration: 180 }
        ];

        // Game state
        let gameState = {
            playerHealth: 100, score: 0, bossHealth: 500, bossMaxHealth: 500,
            gameRunning: false, loginShown: false, mouseX: 0, mouseY: 0,
            playerX: canvas.width / 2, playerY: canvas.height - 150,
            playerSpeed: 6, currentLevel: 1, maxLevel: 3,
            rapidFireActive: false, rapidFireTimer: 0,
            freezeActive: false, freezeTimer: 0
        };

        let keys = { w: false, a: false, s: false, d: false };

        // Boss class
        class Boss {
            constructor(level) {
                this.config = bossConfigs[level - 1];
                this.x = canvas.width / 2; this.y = 150; this.width = 180; this.height = 220;
                this.phase = 1; this.attackTimer = 0; this.attackCooldown = this.config.attackCooldown;
                this.wobble = 0; this.hitFlash = 0; this.eyeOffset = 0; this.level = level;
            }

            update() {
                this.wobble += 0.05;
                
                // Don't attack or move if frozen
                if (!gameState.freezeActive) {
                    this.attackTimer++;
                    const moveSpeed = this.level * 0.3;
                    this.x = canvas.width / 2 + Math.sin(this.wobble * moveSpeed) * 120;
                }
                
                if (this.hitFlash > 0) this.hitFlash--;
                
                if (gameState.bossHealth < gameState.bossMaxHealth * 0.5) {
                    this.phase = 2; this.attackCooldown = this.config.attackCooldown * 0.75;
                }
                if (gameState.bossHealth < gameState.bossMaxHealth * 0.25) {
                    this.phase = 3; this.attackCooldown = this.config.attackCooldown * 0.5;
                }

                if (this.attackTimer >= this.attackCooldown && !gameState.freezeActive) { 
                    this.attack(); 
                    this.attackTimer = 0; 
                }

                this.eyeOffset = Math.sin(this.wobble * 2) * 5;
            }

            attack() {
                const speed = this.config.projectileSpeed;
                
                if (this.phase === 1) {
                    const spreadCount = this.level + 2;
                    for (let i = 0; i < spreadCount; i++) {
                        const angle = (i / (spreadCount - 1) - 0.5) * Math.PI * 0.6;
                        projectiles.push(new Projectile(this.x, this.y + 80, Math.sin(angle) * speed, Math.cos(angle) * speed, 'enemy'));
                    }
                } else if (this.phase === 2) {
                    const circleCount = 6 + this.level * 2;
                    for (let i = 0; i < circleCount; i++) {
                        const angle = (Math.PI * 2 / circleCount) * i;
                        projectiles.push(new Projectile(this.x, this.y + 80, Math.cos(angle) * speed, Math.sin(angle) * speed, 'enemy'));
                    }
                } else {
                    const rainCount = 3 + this.level * 2;
                    for (let i = 0; i < rainCount; i++) {
                        projectiles.push(new Projectile(Math.random() * canvas.width, -50, 0, speed * 1.2, 'enemy'));
                    }
                }
            }

            hit() {
                gameState.bossHealth -= 10; this.hitFlash = 10; gameState.score += 10;
                if (gameState.bossHealth <= 0) {
                    if (gameState.currentLevel < gameState.maxLevel) nextLevel();
                    else endGame(true);
                }
            }

            draw() {
                ctx.save();
                
                // Freeze effect
                if (gameState.freezeActive) {
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#4169e1';
                    ctx.globalAlpha = 0.7;
                }
                
                if (this.hitFlash > 0) { ctx.shadowBlur = 20; ctx.shadowColor = 'red'; }
                const wobbleY = Math.sin(this.wobble) * 10;
                
                ctx.fillStyle = this.hitFlash > 0 ? '#ff6666' : '#8B4513';
                ctx.beginPath(); ctx.ellipse(this.x - 35, this.y + 130, 18, 50, 0, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.ellipse(this.x + 35, this.y + 130, 18, 50, 0, 0, Math.PI * 2); ctx.fill();

                ctx.fillStyle = this.hitFlash > 0 ? '#ff8888' : this.config.color;
                ctx.strokeStyle = '#000'; ctx.lineWidth = 4;
                ctx.beginPath(); ctx.ellipse(this.x, this.y + wobbleY, this.width / 2, this.height / 2, 0, 0, Math.PI * 2);
                ctx.fill(); ctx.stroke();

                ctx.strokeStyle = '#000'; ctx.lineWidth = 10; ctx.lineCap = 'round';
                const armSwing = Math.sin(this.wobble * 2) * 25;
                ctx.beginPath(); ctx.moveTo(this.x - 65, this.y + 20);
                ctx.quadraticCurveTo(this.x - 130, this.y + armSwing, this.x - 110, this.y + 80); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(this.x + 65, this.y + 20);
                ctx.quadraticCurveTo(this.x + 130, this.y - armSwing, this.x + 110, this.y + 80); ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(this.x - 110, this.y + 80, 13, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                ctx.beginPath(); ctx.arc(this.x + 110, this.y + 80, 13, 0, Math.PI * 2); ctx.fill(); ctx.stroke();

                ctx.fillStyle = this.hitFlash > 0 ? '#ffaaaa' : '#FFA07A';
                ctx.beginPath(); ctx.ellipse(this.x, this.y - 70, 70, 80, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();

                const eyeY = this.y - 80;
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.ellipse(this.x - 25, eyeY, 22, 30, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                ctx.fillStyle = this.config.eyeColor; // Different eye colors per boss
                ctx.beginPath(); ctx.ellipse(this.x - 25 + this.eyeOffset, eyeY + 5, 10, 18, 0, 0, Math.PI * 2); ctx.fill();

                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.ellipse(this.x + 25, eyeY, 22, 30, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                ctx.fillStyle = this.config.eyeColor;
                ctx.beginPath(); ctx.ellipse(this.x + 25 + this.eyeOffset, eyeY + 5, 10, 18, 0, 0, Math.PI * 2); ctx.fill();

                ctx.strokeStyle = '#000'; ctx.lineWidth = 4;
                ctx.beginPath();
                if (this.level === 3) { 
                    // Angry mouth
                    ctx.moveTo(this.x - 25, this.y - 50); 
                    ctx.lineTo(this.x + 25, this.y - 50); 
                } else if (this.level === 2) {
                    // Wavy smile
                    ctx.moveTo(this.x - 25, this.y - 55);
                    ctx.quadraticCurveTo(this.x, this.y - 50, this.x + 25, this.y - 55);
                } else {
                    ctx.arc(this.x, this.y - 55, 25, 0, Math.PI);
                }
                ctx.stroke();

                // Different crown styles per level
                const crownColors = ['#FFD700', '#C0C0C0', '#CD7F32'];
                ctx.fillStyle = crownColors[this.level - 1]; 
                ctx.strokeStyle = '#000'; 
                ctx.lineWidth = 3;
                ctx.beginPath(); 
                
                if (this.config.accessories === 'crown_gems') {
                    // Queen with gems
                    ctx.moveTo(this.x - 55, this.y - 135); 
                    ctx.lineTo(this.x - 35, this.y - 165);
                    ctx.lineTo(this.x - 18, this.y - 145); 
                    ctx.lineTo(this.x, this.y - 175);
                    ctx.lineTo(this.x + 18, this.y - 145); 
                    ctx.lineTo(this.x + 35, this.y - 165);
                    ctx.lineTo(this.x + 55, this.y - 135); 
                    ctx.lineTo(this.x - 55, this.y - 135);
                    ctx.fill(); 
                    ctx.stroke();
                    
                    // Add gems
                    ctx.fillStyle = '#ff00ff';
                    ctx.beginPath(); ctx.arc(this.x, this.y - 170, 5, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(this.x - 35, this.y - 160, 4, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(this.x + 35, this.y - 160, 4, 0, Math.PI * 2); ctx.fill();
                } else if (this.config.accessories === 'crown_spikes') {
                    // Lord with spikes
                    ctx.moveTo(this.x - 60, this.y - 135); 
                    ctx.lineTo(this.x - 45, this.y - 175);
                    ctx.lineTo(this.x - 30, this.y - 140); 
                    ctx.lineTo(this.x - 15, this.y - 180);
                    ctx.lineTo(this.x, this.y - 140);
                    ctx.lineTo(this.x + 15, this.y - 180);
                    ctx.lineTo(this.x + 30, this.y - 140);
                    ctx.lineTo(this.x + 45, this.y - 175);
                    ctx.lineTo(this.x + 60, this.y - 135); 
                    ctx.lineTo(this.x - 60, this.y - 135);
                    ctx.fill(); 
                    ctx.stroke();
                } else {
                    // King - simple crown
                    ctx.moveTo(this.x - 55, this.y - 135); 
                    ctx.lineTo(this.x - 35, this.y - 160);
                    ctx.lineTo(this.x - 18, this.y - 145); 
                    ctx.lineTo(this.x, this.y - 170);
                    ctx.lineTo(this.x + 18, this.y - 145); 
                    ctx.lineTo(this.x + 35, this.y - 160);
                    ctx.lineTo(this.x + 55, this.y - 135); 
                    ctx.lineTo(this.x - 55, this.y - 135);
                    ctx.fill(); 
                    ctx.stroke();
                }

                // Ice overlay if frozen
                if (gameState.freezeActive) {
                    ctx.strokeStyle = '#4169e1';
                    ctx.lineWidth = 4;
                    for (let i = 0; i < 5; i++) {
                        const angle = (Math.PI * 2 / 5) * i;
                        const x1 = this.x + Math.cos(angle) * 40;
                        const y1 = this.y + Math.sin(angle) * 40;
                        const x2 = this.x + Math.cos(angle + Math.PI * 2 / 10) * 60;
                        const y2 = this.y + Math.sin(angle + Math.PI * 2 / 10) * 60;
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }

                ctx.restore();
            }
        }

        // Projectile class
        class Projectile {
            constructor(x, y, vx, vy, type) {
                this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.type = type;
                this.radius = type === 'player' ? 8 : 12; this.dead = false; this.rotation = 0;
            }

            update() {
                this.x += this.vx; this.y += this.vy; this.rotation += 0.2;
                if (this.x < -50 || this.x > canvas.width + 50 || this.y < -50 || this.y > canvas.height + 50) this.dead = true;

                if (this.type === 'player') {
                    const dx = this.x - boss.x; const dy = this.y - boss.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < boss.width / 2) {
                        boss.hit(); this.dead = true;
                        for (let i = 0; i < 8; i++) particles.push(new Particle(this.x, this.y, '#ff0000'));
                    }
                }

                if (this.type === 'enemy') {
                    const dx = this.x - gameState.playerX;
                    const dy = this.y - gameState.playerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 20) { // Smaller collision radius for smaller player
                        gameState.playerHealth -= boss.config.damage; // Use boss-specific damage
                        this.dead = true;
                        for (let i = 0; i < 6; i++) particles.push(new Particle(this.x, this.y, '#ffff00'));
                        if (gameState.playerHealth <= 0) endGame(false);
                    }
                }
            }

            draw() {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation);
                if (this.type === 'player') {
                    ctx.fillStyle = '#00ffff'; ctx.shadowBlur = 15; ctx.shadowColor = '#00ffff';
                    ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
                } else {
                    ctx.fillStyle = '#ff00ff'; ctx.shadowBlur = 15; ctx.shadowColor = '#ff00ff';
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI * 2 / 6) * i;
                        const r = i % 2 === 0 ? this.radius : this.radius * 0.5;
                        const x = Math.cos(angle) * r; const y = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                    }
                    ctx.closePath(); ctx.fill();
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
                }
                ctx.restore();
            }
        }

        // Particle class
        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y; this.vx = (Math.random() - 0.5) * 8; this.vy = (Math.random() - 0.5) * 8;
                this.color = color; this.life = 30; this.maxLife = 30; this.dead = false;
            }
            update() { this.x += this.vx; this.y += this.vy; this.vy += 0.2; this.life--; if (this.life <= 0) this.dead = true; }
            draw() { const alpha = this.life / this.maxLife; ctx.fillStyle = this.color; ctx.globalAlpha = alpha; ctx.fillRect(this.x - 3, this.y - 3, 6, 6); ctx.globalAlpha = 1; }
        }

        // Powerup class
        class Powerup {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.config = powerupTypes.find(p => p.type === type);
                this.radius = 20;
                this.dead = false;
                this.wobble = Math.random() * Math.PI * 2;
                this.floatSpeed = 0.05;
            }

            update() {
                this.wobble += this.floatSpeed;
                // Make it fall down
                this.y += 2;
                // Add wobble to x position
                this.x += Math.sin(this.wobble) * 1.5;
                
                // Check collision with player
                const dx = this.x - gameState.playerX;
                const dy = this.y - gameState.playerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < this.radius + 20) {
                    this.collect();
                    this.dead = true;
                }

                // Remove if off screen
                if (this.y > canvas.height + 50 || this.x < -50 || this.x > canvas.width + 50) this.dead = true;
            }

            collect() {
                if (this.type === 'rapidfire') {
                    gameState.rapidFireActive = true;
                    gameState.rapidFireTimer = this.config.duration;
                } else if (this.type === 'health') {
                    gameState.playerHealth = Math.min(100, gameState.playerHealth + 25);
                } else if (this.type === 'freeze') {
                    gameState.freezeActive = true;
                    gameState.freezeTimer = this.config.duration;
                }
                
                // Show notification
                showPowerupNotification(this.config.name);
                
                // Particles
                for (let i = 0; i < 15; i++) {
                    particles.push(new Particle(this.x, this.y, this.config.color));
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Glow effect
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.config.color;
                
                // Outer circle
                ctx.fillStyle = this.config.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner circle
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 0.6, 0, Math.PI * 2);
                ctx.fill();
                
                // Icon based on type
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                
                if (this.type === 'rapidfire') {
                    // Lightning bolt
                    ctx.beginPath();
                    ctx.moveTo(-5, -10);
                    ctx.lineTo(3, 0);
                    ctx.lineTo(-2, 0);
                    ctx.lineTo(5, 10);
                    ctx.stroke();
                } else if (this.type === 'health') {
                    // Plus sign
                    ctx.beginPath();
                    ctx.moveTo(0, -8);
                    ctx.lineTo(0, 8);
                    ctx.moveTo(-8, 0);
                    ctx.lineTo(8, 0);
                    ctx.stroke();
                } else if (this.type === 'freeze') {
                    // Snowflake
                    for (let i = 0; i < 6; i++) {
                        ctx.save();
                        ctx.rotate((Math.PI / 3) * i);
                        ctx.beginPath();
                        ctx.moveTo(0, -8);
                        ctx.lineTo(0, 8);
                        ctx.stroke();
                        ctx.restore();
                    }
                }
                
                ctx.restore();
            }
        }

        // Player class
        class Player {
            constructor() {
                this.x = gameState.playerX; this.y = gameState.playerY;
                this.baseY = canvas.height - 150; this.duckY = canvas.height - 120;
                this.velY = 0; this.gravity = 0.6; this.jumpPower = -12;
                this.isJumping = false; this.isDucking = false; this.animFrame = 0; this.animSpeed = 0.15;
            }

            update() {
                this.x = gameState.playerX;
                if (this.isJumping) {
                    this.velY += this.gravity; this.y += this.velY;
                    if (this.y >= this.baseY) { this.y = this.baseY; this.velY = 0; this.isJumping = false; }
                } else if (this.isDucking) { this.y = this.duckY; }
                else { this.y = this.baseY; }
                this.animFrame += this.animSpeed; if (this.animFrame >= 4) this.animFrame = 0;
                gameState.playerY = this.y;
            }

            jump() { if (!this.isJumping && !this.isDucking) { this.isJumping = true; this.velY = this.jumpPower; } }
            duck(isDucking) { if (!this.isJumping) this.isDucking = isDucking; }

            draw() {
                ctx.save();
                const bounce = Math.sin(this.animFrame * Math.PI) * 3;
                const sway = Math.sin(this.animFrame * Math.PI / 2) * 2;
                ctx.fillStyle = '#fff'; ctx.strokeStyle = '#000'; ctx.lineWidth = 3;
                const scale = this.isDucking ? 0.5 : 0.7; // Made smaller (was 0.7 : 1)
                const drawY = this.y - (this.isDucking ? 0 : bounce);
                
                ctx.beginPath(); ctx.ellipse(this.x, drawY, 25 * scale, 30 * scale, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(this.x - 25 * scale, drawY - 5 * scale, 50 * scale, 10 * scale);
                ctx.strokeRect(this.x - 25 * scale, drawY - 5 * scale, 50 * scale, 10 * scale);
                
                if (!this.isDucking) {
                    ctx.fillStyle = '#fff';
                    ctx.beginPath(); ctx.arc(this.x + sway, drawY - 40 * scale, 20 * scale, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                    const eyeBlink = Math.floor(this.animFrame) === 0 ? 0.5 : 1;
                    ctx.fillStyle = '#000';
                    ctx.beginPath(); ctx.arc(this.x - 8 * scale + sway, drawY - 42 * scale, 4 * eyeBlink * scale, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(this.x + 8 * scale + sway, drawY - 42 * scale, 4 * eyeBlink * scale, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(this.x + sway, drawY - 35 * scale, 8 * scale, 0, Math.PI); ctx.stroke();
                    ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 4;
                    ctx.beginPath(); ctx.moveTo(this.x - 15 * scale + sway, drawY - 50 * scale); ctx.lineTo(this.x - 20 * scale + sway, drawY - 70 * scale); ctx.stroke();
                }
                
                ctx.strokeStyle = '#000'; ctx.lineWidth = 5 * scale; ctx.lineCap = 'round';
                ctx.beginPath(); ctx.moveTo(this.x - 20 * scale, drawY);
                ctx.lineTo(this.x - 35 * scale, drawY + 15 * scale + Math.sin(this.animFrame * Math.PI * 2) * 10 * scale); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(this.x + 20 * scale, drawY);
                ctx.lineTo(this.x + 35 * scale, drawY + 15 * scale - Math.sin(this.animFrame * Math.PI * 2) * 10 * scale); ctx.stroke();
                
                ctx.lineWidth = 6 * scale; const legKick = Math.sin(this.animFrame * Math.PI * 2) * 15 * scale;
                ctx.beginPath(); ctx.moveTo(this.x - 10 * scale, drawY + 28 * scale);
                ctx.lineTo(this.x - 10 * scale - legKick, drawY + 50 * scale); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(this.x + 10 * scale, drawY + 28 * scale);
                ctx.lineTo(this.x + 10 * scale + legKick, drawY + 50 * scale); ctx.stroke();
                
                ctx.fillStyle = '#333'; ctx.strokeStyle = '#000'; ctx.lineWidth = 3;
                const gunAngle = Math.atan2(gameState.mouseY - drawY, gameState.mouseX - this.x);
                ctx.save(); ctx.translate(this.x + 25 * scale, drawY); ctx.rotate(gunAngle);
                ctx.fillRect(0, -8 * scale, 35 * scale, 16 * scale); ctx.strokeRect(0, -8 * scale, 35 * scale, 16 * scale); ctx.restore();
                ctx.restore();
            }
        }

        // Game objects
        let boss = new Boss(1); let player = new Player();
        let projectiles = []; let particles = []; let powerups = []; 
        let shootCooldown = 0;
        let powerupSpawnTimer = 0;
        let powerupNotification = { text: '', timer: 0 };
        let userCredentials = { username: '', email: '' };

        function showPowerupNotification(text) {
            powerupNotification.text = text;
            powerupNotification.timer = 120;
        }

        function spawnPowerup() {
            const randomType = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];
            const x = 100 + Math.random() * (canvas.width - 200);
            powerups.push(new Powerup(x, -50, randomType.type));
        }

        // Login functions
        function showLogin() {
            if (!gameState.loginShown) {
                gameState.loginShown = true;
                document.getElementById('loginModal').style.display = 'block';
            }
        }
        
        function login() {
            const username = document.getElementById('username').value || 'Player';
            const email = document.getElementById('email').value || 'player@game.com';
            
            userCredentials.username = username;
            userCredentials.email = email;
            
            document.getElementById('loginModal').style.display = 'none';
            gameState.gameRunning = true;
            gameLoop();
        }

        function logout() {
            document.getElementById('loggedInApp').style.display = 'none';
            document.getElementById('mainContainer').style.display = 'flex';
            restartGame();
        }

        function showLoggedInApp() {
            document.getElementById('mainContainer').style.display = 'none';
            document.getElementById('loggedInApp').style.display = 'block';
            document.getElementById('appUsername').textContent = userCredentials.username;
            document.getElementById('appEmail').textContent = userCredentials.email;
            document.getElementById('appScore').textContent = gameState.score;
        }

        // Mouse controls
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            
            // Account for canvas scaling
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            gameState.mouseX = (e.clientX - rect.left) * scaleX;
            gameState.mouseY = (e.clientY - rect.top) * scaleY;
            
            crosshair.style.left = e.clientX + 'px';
            crosshair.style.top = e.clientY + 'px';
            crosshair.style.display = 'block';
        });

        canvas.addEventListener('click', (e) => {
            if (!gameState.gameRunning) {
                showLogin();
                return;
            }
            
            const rapidFireCooldown = gameState.rapidFireActive ? 3 : 10;
            if (shootCooldown <= 0) {
                const rect = canvas.getBoundingClientRect();
                
                // Account for canvas scaling - convert screen coordinates to canvas coordinates
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const targetX = (e.clientX - rect.left) * scaleX;
                const targetY = (e.clientY - rect.top) * scaleY;
                
                // Calculate gun position (gun is at player position, slightly offset)
                const scale = player.isDucking ? 0.5 : 0.7;
                const gunX = gameState.playerX + 25 * scale;
                const gunY = gameState.playerY;
                
                // Calculate direction from gun to cursor
                const dx = targetX - gunX;
                const dy = targetY - gunY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const speed = 15;
                
                // Spawn bullet from gun position
                projectiles.push(new Projectile(
                    gunX, 
                    gunY, 
                    (dx / distance) * speed, 
                    (dy / distance) * speed, 
                    'player'
                ));
                shootCooldown = rapidFireCooldown;
            }
        });

        // Keyboard controls
        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (!gameState.gameRunning && (key === 'w' || key === 'a' || key === 's' || key === 'd')) {
                showLogin();
                e.preventDefault();
                return;
            }
            if (key in keys) {
                keys[key] = true;
                if (key === 'w') player.jump();
                if (key === 's') player.duck(true);
                e.preventDefault();
            }
        });

        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (key in keys) {
                keys[key] = false;
                if (key === 's') player.duck(false);
                e.preventDefault();
            }
        });

        // Game loop
        function gameLoop() {
            // Always continue the animation loop
            requestAnimationFrame(gameLoop);
            
            if (!gameState.gameRunning) return;
            
            ctx.fillStyle = 'rgba(135, 206, 235, 0.3)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#90EE90'; ctx.fillRect(0, canvas.height - 100, canvas.width, 100);
            ctx.strokeStyle = '#000'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.moveTo(0, canvas.height - 100); ctx.lineTo(canvas.width, canvas.height - 100); ctx.stroke();

            if (keys.a) gameState.playerX -= gameState.playerSpeed;
            if (keys.d) gameState.playerX += gameState.playerSpeed;
            gameState.playerX = Math.max(50, Math.min(canvas.width - 50, gameState.playerX));

            // Update powerup timers
            if (gameState.rapidFireActive) {
                gameState.rapidFireTimer--;
                if (gameState.rapidFireTimer <= 0) gameState.rapidFireActive = false;
            }
            if (gameState.freezeActive) {
                gameState.freezeTimer--;
                if (gameState.freezeTimer <= 0) gameState.freezeActive = false;
            }

            // Spawn powerups occasionally
            powerupSpawnTimer++;
            if (powerupSpawnTimer > 400 + Math.random() * 300) {
                spawnPowerup();
                powerupSpawnTimer = 0;
            }

            player.update(); boss.update(); boss.draw();
            
            // Auto-fire during rapid fire mode
            if (gameState.rapidFireActive && shootCooldown <= 0) {
                const scale = player.isDucking ? 0.5 : 0.7;
                const gunX = gameState.playerX + 25 * scale;
                const gunY = gameState.playerY;
                
                const dx = gameState.mouseX - gunX;
                const dy = gameState.mouseY - gunY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const speed = 15;
                
                if (distance > 10) { // Only shoot if cursor is not too close
                    projectiles.push(new Projectile(
                        gunX, 
                        gunY, 
                        (dx / distance) * speed, 
                        (dy / distance) * speed, 
                        'player'
                    ));
                    shootCooldown = 3; // Rapid fire cooldown
                }
            }
            
            projectiles = projectiles.filter(p => !p.dead);
            projectiles.forEach(p => { p.update(); p.draw(); });
            
            particles = particles.filter(p => !p.dead);
            particles.forEach(p => { p.update(); p.draw(); });
            
            powerups = powerups.filter(p => !p.dead);
            powerups.forEach(p => { p.update(); p.draw(); });
            
            player.draw();
            if (shootCooldown > 0) shootCooldown--;

            // Draw powerup notification
            if (powerupNotification.timer > 0) {
                powerupNotification.timer--;
                const alpha = Math.min(1, powerupNotification.timer / 30);
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = '#fff';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 4;
                ctx.font = 'bold 32px Courier New';
                ctx.textAlign = 'center';
                ctx.strokeText(powerupNotification.text, canvas.width / 2, 100);
                ctx.fillText(powerupNotification.text, canvas.width / 2, 100);
                ctx.restore();
            }

            // Draw active powerup indicators
            let indicatorY = canvas.height - 120;
            if (gameState.rapidFireActive) {
                ctx.fillStyle = 'rgba(0, 255, 255, 0.8)';
                ctx.fillRect(10, indicatorY, 150, 8);
                ctx.fillStyle = '#00ffff';
                ctx.fillRect(10, indicatorY, (gameState.rapidFireTimer / 300) * 150, 8);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(10, indicatorY, 150, 8);
                indicatorY += 15;
            }
            if (gameState.freezeActive) {
                ctx.fillStyle = 'rgba(65, 105, 225, 0.8)';
                ctx.fillRect(10, indicatorY, 150, 8);
                ctx.fillStyle = '#4169e1';
                ctx.fillRect(10, indicatorY, (gameState.freezeTimer / 180) * 150, 8);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(10, indicatorY, 150, 8);
            }

            document.getElementById('playerHealth').textContent = Math.max(0, gameState.playerHealth);
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('currentLevel').textContent = gameState.currentLevel;
            document.getElementById('bossHealthFill').style.width = (gameState.bossHealth / gameState.bossMaxHealth * 100) + '%';
            document.getElementById('bossName').textContent = boss.config.name;
        }

        function nextLevel() {
            gameState.currentLevel++;
            const config = bossConfigs[gameState.currentLevel - 1];
            gameState.bossHealth = config.health;
            gameState.bossMaxHealth = config.health;
            
            // Reset powerups and projectiles
            projectiles = [];
            particles = [];
            powerups = [];
            powerupSpawnTimer = 0;
            
            // Keep powerup effects active through levels
            boss = new Boss(gameState.currentLevel);
            
            const gameOverDiv = document.getElementById('gameOver');
            const gameOverText = document.getElementById('gameOverText');
            const gameOverSubtext = document.getElementById('gameOverSubtext');
            const retryButton = document.getElementById('retryButton');
            const nextLevelButton = document.getElementById('nextLevelButton');
            
            gameOverText.textContent = `üéâ LEVEL ${gameState.currentLevel - 1} COMPLETE! üéâ`;
            gameOverSubtext.textContent = `Get ready to face ${config.name}!`;
            retryButton.style.display = 'none';
            nextLevelButton.style.display = 'inline-block';
            gameOverDiv.style.display = 'block';
            
            gameState.gameRunning = false;
        }

        function continueToNextLevel() {
            const gameOverDiv = document.getElementById('gameOver');
            const retryButton = document.getElementById('retryButton');
            const nextLevelButton = document.getElementById('nextLevelButton');
            
            gameOverDiv.style.display = 'none';
            retryButton.style.display = 'inline-block';
            nextLevelButton.style.display = 'none';
            gameState.gameRunning = true;
        }

        function endGame(victory) {
            gameState.gameRunning = false;
            
            if (victory) {
                // Show the logged in app
                setTimeout(() => {
                    showLoggedInApp();
                }, 1000);
            } else {
                // Show game over screen denying access
                const gameOverDiv = document.getElementById('gameOver');
                const gameOverText = document.getElementById('gameOverText');
                const gameOverSubtext = document.getElementById('gameOverSubtext');
                
                gameOverText.textContent = '‚ùå ACCESS DENIED ‚ùå';
                gameOverSubtext.textContent = `You failed the challenge! Score: ${gameState.score} - Level ${gameState.currentLevel}\nDefeat all bosses to access the app!`;
                
                gameOverDiv.style.display = 'block';
            }
        }

        function restartGame() {
            const config = bossConfigs[0];
            gameState = {
                playerHealth: 100, score: 0, bossHealth: config.health, bossMaxHealth: config.health,
                gameRunning: true, loginShown: true, mouseX: 0, mouseY: 0,
                playerX: canvas.width / 2, playerY: canvas.height - 150,
                playerSpeed: 6, currentLevel: 1, maxLevel: 3,
                rapidFireActive: false, rapidFireTimer: 0,
                freezeActive: false, freezeTimer: 0
            };
            projectiles = []; particles = []; powerups = [];
            boss = new Boss(1); player = new Player();
            powerupSpawnTimer = 0;
            powerupNotification = { text: '', timer: 0 };
            document.getElementById('gameOver').style.display = 'none'; 
            gameLoop();
        }

        // Initial display
        ctx.fillStyle = 'rgba(135, 206, 235, 1)'; ctx.fillRect(0, 0, canvas.width,canvas.height);
        ctx.fillStyle = "#000"; ctx.font = "bold 32px Courier New"; ctx.textAlign = "center";
        ctx.fillText("Press any key to play!", canvas.width / 2, canvas.height / 2);
    </script>
</body>
</html>
